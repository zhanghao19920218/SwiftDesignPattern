## 创建型模式

创建型模式提供了创建对象的机制， 能够提升已有代码的灵活性和可复用性。

### 工厂模式

* 在父类中提供一个创建对象的接口以允许子类决定实例化对象的类型。

> 方法
>
> 工厂方法模式建议使用特殊的工厂方法代替对于对象构造函数的直接调用（即使用`new`运算符）。不用担心，对象仍然通过`new`运算符创建，只是该运算符改在工厂方法中调用罢了。工厂方法返回的对象通常被称为“产品”。

**仅当这些产品具有共同的基类或者接口时，子类才能返回不同类型的产品，同时基类中的工厂方法还应将其返回类型声明为这一共有接口**

![solution2-zh](/Users/mason/Desktop/SwiftModel/创建型模式/solution2-zh.png)

举例来说，  `卡车`Truck和 `轮船`Ship类都必须实现 `运输`Transport接口， 该接口声明了一个名为 `deliver`交付的方法。 每个类都将以不同的方式实现该方法： 卡车走陆路交付货物， 轮船走海路交付货物。  `陆路运输`Road­Logistics类中的工厂方法返回卡车对象， 而 `海路运输`Sea­Logistics类则返回轮船对象。

#### 实战写法

* 目前常用就是网络请求的面向协议写法, Model遵循Codable, 在请求成功后的函数里面写解析JSONDecoder()进行解析, 后面直接调用起来只需要一行代码
* 抽象层（就是将网络请求的通用部分抽象成一个协议TargetType, 定义BaseUrl, Headers, Method, RequestUrl）
* 返回数据 (抽象成Codable), JSONDecoder

#### 优点

* 避免创建者和具体产品之间的紧密耦合，RequestUtil并没有牵涉很多继承请求和解析的类
* 单一职责原则。你可以将产品创建代码放在程序的单一位置，使代码容易维护
* 开闭原则。无需更改现有客户端代码，可以在程序中引入新的产品类型，只要继承于产品类，比如TargetType, Codable



### 抽象工厂模式

* 创建型设计模式，他能创建一些列相关的对象，而无需指定其具体类

#### 问题

假设你正在开发一款家具商店模拟器。 你的代码中包括一些类， 用于表示：

1. 一系列相关产品， 例如 `椅子`Chair 、  `沙发`Sofa和 `咖啡桌`Coffee­Table 。
2. 系列产品的不同变体。 例如， 你可以使用 `现代`Modern 、  `维多利亚`Victorian 、  `装饰风艺术`Art­Deco等风格生成 `椅子` 、  `沙发`和 `咖啡桌` 。

#### 解决方法

首先，抽象工厂模式建议为系列中的每件产品明确声明接口（例如椅子、沙发或咖啡桌）。然后，确保所有产品变体都继承这些接口。例如，所有风格的椅子都实现`椅子`接口;所有风格的咖啡桌都实现`咖啡桌`接口，以此类推。

接下来， 我们需要声明*抽象工厂*——包含系列中所有产品构造方法的接口。 例如 `create­Chair`创建椅子 、  `create­Sofa`创建沙发和 `create­Coffee­Table`创建咖啡桌 。 这些方法必须返回**抽象**产品类型， 即我们之前抽取的那些接口：  `椅子` ，  `沙发`和 `咖啡桌`等等。

#### 抽象工厂模式适合应用场景

1. **如果代码需要与多个不同系列的相关产品交互****，** **但是由于无法提前获取相关信息****，** **或者出于对未来扩展性的考虑****，** **你不希望代码基于产品的具体类进行构建****，** **在这种情况下****，** **你可以使用抽象工厂****。
2. 抽象工厂为你提供了一个接口， 可用于创建每个系列产品的对象。 只要代码通过该接口创建对象， 那么你就不会生成与应用程序已生成的产品类型不一致的产品。
3. **如果你有一个基于一组**[抽象方法](https://refactoringguru.cn/design-patterns/factory-method)**的类****，** **且其主要功能因此变得不明确****，** **那么在这种情况下可以考虑使用抽象工厂模式****。**
4. 在设计良好的程序中， *每个类仅负责一件事*。 如果一个类与多种类型产品交互， 就可以考虑将工厂方法抽取到独立的工厂类或具备完整功能的抽象工厂类中。

#### 重点

* 由抽象工厂类，实例化两种工厂类，抽象产品协议，实例化的产品协议，单例来使用
* 工厂类用来创建抽象协议产品的
* 工厂抽象类的方法返回抽象产品，实例化类和实例化方法直接显示数据，减少耦合性

### 生成器模式

#### 意图

**生成器模式** 是一种创造型设计模式，使你能够分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象

#### 问题

假设有这样一个复杂对象， 在对其进行构造时需要对诸多成员变量和嵌套对象进行繁复的初始化工作。 这些初始化代码通常深藏于一个包含众多参数且让人基本看不懂的构造函数中； 甚至还有更糟糕的情况， 那就是这些代码散落在客户端代码的多个位置。(*比如第三方库的初始化参数*)

#### 错误的解决方案

1. 使用基类，然后不停的继承扩展，生成了一个庞大的类
2. 直接创建一个庞大的类，初始化参数会非常庞大

#### 解决方案

`生成器模式让你能够分步骤创建复杂对象。 生成器不允许其他对象访问正在创建中的产品。`

该模式会将对象构造过程划分为一组步骤，比如`buildWalls`和`buildDoor`,每次创建对象，你都需要通过生成器对象执行一系列步骤。重点在于你无需调用所有步骤，而只需调用创建特定对象配置所需的那些步骤即可。

当你需要创建不同形式的产品时，其中的一些构造步骤可能需要不同实现。例如，木屋的房门可能需要使用木头制造，而城堡的房门则必须使用石头制造

**主管**

你可以进一步将用于创建产品的一系列生成器步骤调用抽取成为单独的*主管*类。 主管类可定义创建步骤的执行顺序， 而生成器则提供这些步骤的实现。

#### 生成器模式适合应用场景

1. **使用生成器模式可避免“重叠构造函数（telescopic constructor)的出现**
2. 生成器模式让你可以分步骤生成对象， 而且允许你仅使用必须的步骤。 应用该模式后， 你再也不需要将几十个参数塞进构造函数里了。
3. **当你希望使用代码创建不同形式的产品** **（****例如石头或木头房屋****）** **时****，** **可使用生成器模式****。**
4. 如果你需要创建的各种形式的产品， 它们的制造过程相似且仅有细节上的差异， 此时可使用生成器模式。
5. **使用生成器构造**[组合](https://refactoringguru.cn/design-patterns/composite)**树或其他复杂对象****。**
6.  生成器模式让你能分步骤构造产品。 你可以延迟执行某些步骤而不会影响最终产品。 你甚至可以递归调用这些步骤， 这在创建对象树时非常方便。
7. 生成器在执行制造步骤时， 不能对外发布未完成的产品。 这可以避免客户端代码获取到不完整结果对象的情况。

#### 实现方法

1. 清晰地定义通用步骤， 确保它们可以制造所有形式的产品。 否则你将无法进一步实施该模式。
2. 在基本生成器接口中声明这些步骤
3. 为每个形式的产品创建具体生成器类， 并实现其构造步骤
4. 不要忘记实现获取构造结果对象的方法。 你不能在生成器接口中声明该方法， 因为不同生成器构造的产品可能没有公共接口， 因此你就不知道该方法返回的对象类型。 但是， 如果所有产品都位于单一类层次中， 你就可以安全地在基本接口中添加获取生成对象的方法。
5. 考虑创建主管类。 它可以使用同一生成器对象来封装多种构造产品的方式
6. 客户端代码会同时创建生成器和主管对象。 构造开始前， 客户端必须将生成器对象传递给主管对象。 通常情况下， 客户端只需调用主管类构造函数一次即可。 主管类使用生成器对象完成后续所有制造任务。 还有另一种方式， 那就是客户端可以将生成器对象直接传递给主管类的制造方法
7. 只有在所有产品都遵循相同接口的情况下， 构造结果可以直接通过主管类获取。 否则， 客户端应当通过生成器获取构造结果。

#### 优点

1. 你可以分步创建对象， 暂缓创建步骤或递归运行创建步骤。
2.  生成不同形式的产品时， 你可以复用相同的制造代码。
3. *单一职责原则*。 你可以将复杂构造代码从产品的业务逻辑中分离出来。

### 原型模式

#### 意图

**原型模式**是一种创造型设计模式，使你能够复制已有对象，而又无需使代码依赖它们所属的类

#### 问题

如果你有一个对象， 并希望生成与其完全相同的一个复制品， 你该如何实现呢？ 首先， 你必须新建一个属于相同类的对象。 然后， 你必须遍历原始对象的所有成员变量， 并将成员变量值复制到新对象中。

不错！ 但有个小问题。 并非所有对象都能通过这种方式进行复制， 因为有些对象可能拥有私有成员变量， 它们在对象本身以外是不可见的。

直接复制还有另外一个问题。 因为你必须知道对象所属的类才能创建复制品， 所以代码必须依赖该类。 即使你可以接受额外的依赖性， 那还有另外一个问题： 有时你只知道对象所实现的接口， 而不知道其所属的具体类， 比如可向方法的某个参数传入实现了某个接口的任何对象。

#### 解决方案

原型模式将克隆过程委派给被克隆的实际对象。 模式为所有支持克隆的对象声明了一个通用接口， 该接口让你能够克隆对象， 同时又无需将代码和对象所属类耦合。 通常情况下， 这样的接口中仅包含一个 `克隆`方法。

例如OC里面的`-(id)copyWithZone`

所有的类对 `克隆`方法的实现都非常相似。 该方法会创建一个当前类的对象， 然后将原始对象所有的成员变量值复制到新建的类中。 你甚至可以复制私有成员变量， 因为绝大部分编程语言都允许对象访问其同类对象的私有成员变量。

支持克隆的对象即为*原型*。 当你的对象有几十个成员变量和几百种类型时， 对其进行克隆甚至可以代替子类的构造。

#### 原型模式适合应用场景

* **如果你需要复制一些对象****，** **同时又希望代码独立于这些对象所属的具体类****，** **可以使用原型模式****。**

* 这一点考量通常出现在代码需要处理第三方代码通过接口传递过来的对象时。 即使不考虑代码耦合的情况， 你的代码也不能依赖这些对象所属的具体类， 因为你不知道它们的具体信息。

  原型模式为客户端代码提供一个通用接口， 客户端代码可通过这一接口与所有实现了克隆的对象进行交互， 它也使得客户端代码与其所克隆的对象具体类独立开来。

* **如果子类的区别仅在于其对象的初始化方式****，** **那么你可以使用该模式来减少子类的数量****。** **别人创建这些子类的目的可能是为了创建特定类型的对象****。**

* 在原型模式中， 你可以使用一系列预生成的、 各种类型的对象作为原型。

* 客户端不必根据需求对子类进行实例化， 只需找到合适的原型并对其进行克隆即可。

#### 优点

1. 你可以克隆对象， 而无需与它们所属的具体类相耦合。
2. 你可以克隆预生成原型， 避免反复运行初始化代码。
3. 你可以更方便地生成复杂对象。
4. 你可以用继承以外的方式来处理复杂对象的不同配置。

### 单例模式

#### 意图

**单例模式**是一种创建型设计模式，让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点

#### 问题

1. 保证一个类只有一个实例
2. 为该实例提供一个全局访问的节点

#### 解决方案

* 将默认构造函数设为私有， 防止其他对象使用单例类的 `new`运算符。
* 新建一个静态构建方法作为构造函数。 该函数会 “偷偷” 调用私有构造函数来创建对象， 并将其保存在一个静态成员变量中。 此后所有对于该函数的调用都将返回这一缓存对象。

#### 单例模式适合应用场景

* **如果程序中的某个类对于所有客户端只有一个可用的实例****，** **可以使用单例模式****。**
* 单例模式禁止通过除特殊构建方法以外的任何方式来创建自身类的对象。 该方法可以创建一个新对象， 但如果该对象已经被创建， 则返回已有的对象。
* **如果你需要更加严格地控制全局变量****，** **可以使用单例模式**
* 单例模式与全局变量不同， 它保证类只存在一个实例。 除了单例类自己以外， 无法通过任何方式替换缓存的实例。

